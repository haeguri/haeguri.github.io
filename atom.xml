<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Devlog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://haeguri.github.io/"/>
  <updated>2019-01-31T16:54:23.159Z</updated>
  <id>https://haeguri.github.io/</id>
  
  <author>
    <name>Haegyun Jung</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CORS(Cross Origin Resource Sharing, 교차 출처 리소스 공유)</title>
    <link href="https://haeguri.github.io/2019/02/01/http-cross-origin-resource-sharing/"/>
    <id>https://haeguri.github.io/2019/02/01/http-cross-origin-resource-sharing/</id>
    <published>2019-01-31T15:19:04.924Z</published>
    <updated>2019-01-31T16:54:23.159Z</updated>
    
    <content type="html"><![CDATA[<h2 id="소개"><a href="#소개" class="headerlink" title="소개"></a>소개</h2><p>브라우저는 동일 출처 정책(Single Origin Policy, SOP)에 의해 스크립트 단에서 다른 도메인의 서버로 HTTP 요청을 하는 것이 제한된다. 예를 들면 브라우저를 통해 “naver.com”이라는 URL의 웹 페이지에서 <code>XMLHttpRequest</code> API를 통해 “open-api.com”의 API 서버에 요청하는 것은 차단된다.</p><blockquote><p><em>대신에 <code>XMLHttpRequest</code>가 아니라 <code>&lt;script&gt;</code>, 혹은 <code>&lt;link&gt;</code>와 같이 태그 형태로 외부의 리소스를 받아오는 것에 대해서는 동일 출처 정책이 적용되지 않는다. 이를 이용한 기법으로는 JSONP가 있다.</em></p></blockquote><p> 점차 웹 어플리케이션의 역할이 커지면서 개발자들은 이 제한을 우회할 수 있는 방법들을 요구하기 시작했다. 그래서 브라우저 벤더사들은 CORS(Cross Origin Resource Sharing, 교차 출처 리소스 공유)라는 메커니즘을 브라우저에 적용했으며, CORS는 W3C의 권고안이 되어 완전한 웹 표준이 되었다. </p><p> 하지만 동일 출처 정책이 없어진 것은 아니며, 추가적인 작업을 해줘야만 서로 다른 도메인 간의 리소스를 공유 할 수 있다. CORS 요청을 가능하게 하기 위해서는 다른 도메인을 가진 서버 쪽에서 <strong>특별한 응답 헤더를 설정</strong> 해야 한다. 앞서 살펴본 경우를 예로 들자면, “naver.com” 서버가 아니라 “open-api.com” 서버 쪽에서 설정해야만 한다.</p><h2 id="매커니즘"><a href="#매커니즘" class="headerlink" title="매커니즘"></a>매커니즘</h2><p> 만약 스크립트 단에서 다른 도메인의 서버로 HTTP 요청을 하게 되면, 브라우저는 실제 요청을 보내기 전에 <strong>‘사전 요청(preflight)’</strong>을 보낸다. 그리고 <strong>‘사전 요청’</strong>에 대한 응답을 받은 후 요청이 가능하다고 판단되면, 브라우저는 원래대로 실제 HTTP 요청을 보낸다. 과정을 요약한다면 다음과 같다.</p><ol><li>(JavaScript) <code>XMLHttpRequest</code>로 HTTP 요청 </li><li>(Browser) 다른 도메인 서버로 가는 HTTP 요청임을 감지</li><li>(Browser) 사전 요청 전송 ( HTTP OPTIONS METHOD )</li><li>(Server) 사전 요청에 대한 응답 전송 (  알맞는 헤더가 설정된 응답 )</li><li>(Browser) CORS 요청가 가능하다고 판단</li><li>(Browser) 원래의 HTTP 요청을 계속 함</li></ol><p> <u>‘1’번</u>을 제외한 나머지 과정은 브라우저와 서버가 알아서 해주는 과정이다. 서버는 이 과정이 시작되기 전에 응답에 알맞는 헤더가 설정되도록 작업하기만 하면 된다. 여기에서 <u>‘3’번</u>의 사전 요청 전송 과정은 생략되는 경우도 있다. 이것은 클라이언트에서 어떤 헤더나 메서드로 요청을 하는가에 따라서 달라진다. </p><h2 id="간단한-요청"><a href="#간단한-요청" class="headerlink" title="간단한 요청"></a>간단한 요청</h2><p> 사전 요청을 하지 않아도 된다고 판단되는 <strong>간단한 CORS 요청</strong>들은 다음의 세가지 조건을 <strong><u>모두 만족</u></strong>해야 한다.</p><ul><li>메서드는 다음 중 하나여야 한다 : <code>GET</code>, <code>HEAD</code>, <code>POST</code></li><li>스크립트에서 수동 설정이 허용되는 헤더는 다음 중 하나여야 한다 : <code>Accept</code>, <code>Accept-Language</code>, <code>Content-Language</code>, <code>Content-Type</code> </li><li><code>Content-Type</code> 헤더 값은 다음 중 하나여야 한다 : <code>application/x-www-form-urlencoded</code>, <code>multipart/form-data</code>, <code>text/plain</code></li></ul><p>그리고 당연한 이야기지만, 이 모든 조건이 만족해도 서버에서 알맞은 헤더가 사전에 설정되어 있지 않으면 브라우저에 의해 CORS 요청은 거부된다.</p><p>아래는 <strong>“foo.example”</strong> 페이지를 보고 있는 브라우저와 <strong>“bar.other”</strong> 서버가 주고받은 HTTP 요청, 응답의 내용이다.</p><pre class=" language-text"><code class="language-text">GET /resources/public-data/ HTTP/1.1Host: bar.otherUser-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1. 9.1b3pre) Gecko/20081130 Minefield/3.1b3preAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: en-us,en;q=0.5Accept-Encoding: gzip,deflateAccept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7Connection: keep-aliveReferer: http://foo.example/examples/access-control/simpleXSInvocation.htmlOrigin: http://foo.exampleHTTP/1.1 200 OKDate: Mon, 01 Dec 2008 00:23:53 GMTServer: Apache/2.0.61 Access-Control-Allow-Origin: *Keep-Alive: timeout=2, max=100Connection: Keep-AliveTransfer-Encoding: chunkedContent-Type: application/xml[XML Data]</code></pre><p>첫 번째 블록은 HTTP GET 요청의 헤더인데, <code>Host</code>와 <code>Origin</code> 헤더의 주소가 다르므로 이 요청은 CORS 요청에 해당된다. 그런데 HTTP 메서드가 GET이고, 스크립트에서 수동 설정되는 헤더는 없기 때문에 브라우저는 사전 요청을 보내지 않는다. </p><p>두 번째 블록은 HTTP GET 요청에 대한 응답의 내용이다. 여기에서 CORS 요청을 가능하게 끔 하는 가장 중요한 헤더는 <code>Access-Control-Allow-Origin</code>이다. 이 헤더가 설정되지 않았거나, <code>*</code> 혹은 <code>http://foo.example</code>이 포함되지 않았다면 요청은 거부되었을 것이다. 이 헤더는 앞에서 말한 것처럼 서버 단에서 별도로 설정해줘야 한다.</p><p>예를 들어서 NodeJS 서버에서 <code>Access-Control-Allow-Origin</code> 헤더를 설정한다면 다음과 같을 것이다.</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// …</span><span class="token keyword">var</span> express <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'express'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> app <span class="token operator">=</span> <span class="token function">express</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">,</span> next<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    res<span class="token punctuation">.</span><span class="token function">header</span><span class="token punctuation">(</span><span class="token string">'Access-Control-Allow-Origin'</span><span class="token punctuation">,</span> <span class="token string">'*'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// …</span></code></pre><h2 id="사전-요청"><a href="#사전-요청" class="headerlink" title="사전 요청"></a>사전 요청</h2><p>간단한 요청이 되는 경우를 제외하고, 다른 출처간의 리소스가 공유되기 전에 브라우저에서 받아들여도 되는 리소스인지 확인하기 위해서는 <strong>사전요청</strong>이 전달된다. 만약 다음의 조건 중 <strong><u>하나라도 해당된다면</u></strong> 실제 HTTP 요청 이전에 <strong>사전 요청</strong>이 전달된다. </p><ul><li>GET, POST, HEAD 이외의 메서드인 요청</li><li>요청이 <code>application/x-www-form-urlencoded</code>, <code>multipart/form-data</code>, <code>text/plain</code> 이외의 값을 가진<code>Content-Type</code>으로 전송될 경우</li><li>커스텀 헤더를 설정하는 경우</li></ul><p>다음은 사전 요청이 전달될 수 있는 자바스크립트의 코드이다.</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> invocation <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> url <span class="token operator">=</span> <span class="token string">'http://bar.other/resources/post-here/'</span><span class="token punctuation">;</span><span class="token keyword">var</span> body <span class="token operator">=</span> <span class="token string">'&lt;?xml version="1.0"?>&lt;person>&lt;name>Arun&lt;/name>&lt;/person>'</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">callOtherDomain</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>invocation<span class="token punctuation">)</span>    <span class="token punctuation">{</span>      invocation<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">'POST'</span><span class="token punctuation">,</span> url<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      invocation<span class="token punctuation">.</span><span class="token function">setRequestHeader</span><span class="token punctuation">(</span><span class="token string">'X-PINGOTHER'</span><span class="token punctuation">,</span> <span class="token string">'pingpong'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      invocation<span class="token punctuation">.</span><span class="token function">setRequestHeader</span><span class="token punctuation">(</span><span class="token string">'Content-Type'</span><span class="token punctuation">,</span> <span class="token string">'application/xml'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      invocation<span class="token punctuation">.</span>onreadystatechange <span class="token operator">=</span> handler<span class="token punctuation">;</span>      invocation<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>body<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// ......</span></code></pre><p>그리고 다음은 위의 스크립트가 실행되면서 브라우저와 서버 간 요청과 응답을 주고받는 내용이다.</p><pre class=" language-text"><code class="language-text">OPTIONS /resources/post-here/ HTTP/1.1Host: bar.otherUser-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3preAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: en-us,en;q=0.5Accept-Encoding: gzip,deflateAccept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7Connection: keep-aliveOrigin: http://foo.exampleAccess-Control-Request-Method: POSTAccess-Control-Request-Headers: X-PINGOTHERHTTP/1.1 200 OKDate: Mon, 01 Dec 2008 01:15:39 GMTServer: Apache/2.0.61 (Unix)Access-Control-Allow-Origin: http://foo.exampleAccess-Control-Allow-Methods: POST, GET, OPTIONSAccess-Control-Allow-Headers: X-PINGOTHERAccess-Control-Max-Age: 1728000Vary: Accept-Encoding, OriginContent-Encoding: gzipContent-Length: 0Keep-Alive: timeout=2, max=100Connection: Keep-AliveContent-Type: text/plainPOST /resources/post-here/ HTTP/1.1Host: bar.otherUser-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3preAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: en-us,en;q=0.5Accept-Encoding: gzip,deflateAccept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7Connection: keep-aliveX-PINGOTHER: pingpongContent-Type: text/xml; charset=UTF-8Referer: http://foo.example/examples/preflightInvocation.htmlContent-Length: 55Origin: http://foo.examplePragma: no-cacheCache-Control: no-cache<?xml version="1.0"?><person><name>Arun</name></person>HTTP/1.1 200 OKDate: Mon, 01 Dec 2008 01:15:40 GMTServer: Apache/2.0.61 (Unix)Access-Control-Allow-Origin: http://foo.exampleVary: Accept-Encoding, OriginContent-Encoding: gzipContent-Length: 235Keep-Alive: timeout=2, max=99Connection: Keep-AliveContent-Type: text/plain[Some GZIP'd payload]</code></pre><p>먼저 살펴볼 부분은 첫 번째 요청인 HTTP OPTIONS 메서드의 사전 요청이다. </p><pre class=" language-text"><code class="language-text">OPTIONS /resources/post-here/ HTTP/1.1Host: bar.otherUser-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3preAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: en-us,en;q=0.5Accept-Encoding: gzip,deflateAccept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7Connection: keep-aliveOrigin: http://foo.exampleAccess-Control-Request-Method: POSTAccess-Control-Request-Headers: X-PINGOTHER</code></pre><p>사전 요청이 일어난 이유는 스크립트를 살펴보면 알 듯이 커스텀 헤더인 <code>X-PINGOTHER</code>이 설정되었기 때문이다. 여기서 <code>Access-Control-Request-Method</code>로는 실제 요청이 어떤 메서드로 이뤄지는지 서버에게 알려준다. <code>Access-Control-Request-Headers</code>는 실제 요청에 어떤 헤더가 세팅될 것인지 알려주는데, 여기에 <code>Content-Type</code>과 같은 기본적인 헤더들은 리스트업되지 않는다. 이 두 개의 헤더는 프로그래머가 직접 설정해주는 것이 아니며, 브라우저에 의해 사전 요청에 자동 삽입되는 헤더이다.</p><p>다음으로 살펴볼 부분은 첫 번째 HTTP OPTIONS 요청에 대한 응답이다.</p><pre class=" language-text"><code class="language-text">HTTP/1.1 200 OKDate: Mon, 01 Dec 2008 01:15:39 GMTServer: Apache/2.0.61 (Unix)Access-Control-Allow-Origin: http://foo.exampleAccess-Control-Allow-Methods: POST, GET, OPTIONSAccess-Control-Allow-Headers: X-PINGOTHERAccess-Control-Max-Age: 1728000Vary: Accept-Encoding, OriginContent-Encoding: gzipContent-Length: 0Keep-Alive: timeout=2, max=100Connection: Keep-AliveContent-Type: text/plain</code></pre><p>OPTIONS 요청에 대한 응답을 살펴보면 <code>Access-Control-Allow-Origin</code> 헤더가 웹 페이지의 출처인 <code>http://foo.example</code>을 가르키고 있다. 그리고 <code>Access-Control-Allow-Methods</code>는 허용되는 HTTP 메서드들을 말하는데, 스크립트 상에서 요청되는 메서드인 POST가 포함되어 있다. 그리고 <code>Access-Control-Allow-Headers</code>는 클라이언트의 요청에 설정됐던 <code>X-PINGOTHER</code> 헤더를 포함하고 있다. 이 OPTIONS 요청에 대한 응답으로 인해서 CORS 요청이 승인되고, 다음으로 실질적인 HTTP POST 요청, 응답이 이뤄진다.</p><p>추가적으로, <code>Access-Control-Max-Age</code> 헤더는 사전 전달 요청이 얼마동안 캐시되는지 알려주는 초 단위의 값이다. 사전 전달 요청이 캐시되면 이 헤더에 설정된 시간 동안은 사전전달 요청이 전달되지 않는다.</p><h2 id="인증을-이용한-요청"><a href="#인증을-이용한-요청" class="headerlink" title="인증을 이용한 요청"></a>인증을 이용한 요청</h2><p>서버와 통신하는 부분의 코드를 살펴보다보면 흔하게 봤었던 것이 <code>withCrendentials</code> 플래그이다. </p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> invocation <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> url <span class="token operator">=</span> <span class="token string">'http://bar.other/resources/credentialed-content/'</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">callOtherDomain</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>invocation<span class="token punctuation">)</span> <span class="token punctuation">{</span>    invocation<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">'GET'</span><span class="token punctuation">,</span> url<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    invocation<span class="token punctuation">.</span>withCredentials <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    invocation<span class="token punctuation">.</span>onreadystatechange <span class="token operator">=</span> handler<span class="token punctuation">;</span>    invocation<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><code>withCredentials</code> 플래그의 역할은 CORS 요청을 하면서 인증 정보(ex. 쿠키, authorization 헤더, 또는 TLS 클라이언트 인증서)를 서버로 보낼 수 있게 해준다. 그러면 서버 쪽 응답에서는 <code>Access-Control-Allow-Credentials</code> 헤더가 <code>true</code>로 설정되어 있어야한다. 스크립트에서 <code>withCredentials</code> 플래그가 설정됐는데도 <code>Access-Control-Allow-Credentials</code> 헤더가 <code>true</code>가 아니라면, 아래와 같이 처리된다.</p><ul><li>사전 요청이 없는 경우에는 브라우저가 요청에 대한 응답을 무시한다.</li><li>사전 요청이 전달되는 경우에는 실질적인 Cross Origin 요청에 인증 정보를 사용될 수 없게 된다.</li></ul><h2 id="참고자료"><a href="#참고자료" class="headerlink" title="참고자료"></a>참고자료</h2><ul><li><a href="https://developer.mozilla.org/ko/docs/Web/HTTP/Access_control_CORS" target="_blank" rel="noopener">https://developer.mozilla.org/ko/docs/Web/HTTP/Access_control_CORS</a></li><li><a href="https://homoefficio.github.io/2015/07/21/Cross-Origin-Resource-Sharing/" target="_blank" rel="noopener">https://homoefficio.github.io/2015/07/21/Cross-Origin-Resource-Sharing/</a></li><li><a href="https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/Access-Control-Allow-Credentials" target="_blank" rel="noopener">https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/Access-Control-Allow-Credentials</a></li></ul>]]></content>
    
    <summary type="html">
    
      서로 다른 도메인간의 리소스를 공유할 수 있게 하는 기법인 CORS에 대해서 알아봅니다.
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CSS Box Model</title>
    <link href="https://haeguri.github.io/2019/01/24/css-box-model/"/>
    <id>https://haeguri.github.io/2019/01/24/css-box-model/</id>
    <published>2019-01-24T13:17:46.398Z</published>
    <updated>2019-01-27T13:59:04.525Z</updated>
    
    <content type="html"><![CDATA[<h2 id="소개"><a href="#소개" class="headerlink" title="소개"></a>소개</h2><p>브라우저는 HTML 문서의 엘리먼트들을 화면에 그리기 위해 각 엘리먼트를 박스(box)로 표현한다. 이 때 모든 HTML 엘리먼트를 둘러싸고 있는 사각형 박스를 <strong>CSS 박스 모델(CSS Box Model)</strong>이라고 한다. <a href="https://www.w3.org/TR/CSS2/box.html" target="_blank" rel="noopener">CSS 2.1 스펙</a>에 의하면 박스 모델을 다음처럼 설명하고 있다.</p><blockquote><p><em>CSS 박스 모델은 문서 트리(document tree)안의 엘리먼트들에 대해 만들어지고, 시각적 형식 모델(visual formatting model)에 따라서 배치되는 사각형 상자를 말한다.</em> </p></blockquote><p>하나의 박스는 컨텐츠 영역(content area), 패딩 영역(padding area), 테두리 영역(border area), 마진 영역(margin area)으로 구성된다. 네 가지의 영역이 박스를 어떻게 구성하는지는 아래의 그림을 통해 쉽게 파악해볼 수 있다.</p><img src="/images/css-box-model/css-box-model.png" width="300" height="238"><h2 id="컨텐츠-영역"><a href="#컨텐츠-영역" class="headerlink" title="컨텐츠 영역"></a>컨텐츠 영역</h2><p>컨텐츠 영역에는 텍스트나 이미지 등 엘리먼트의 실제 내용이 있다. 컨텐츠 영역의 크기를 명시적으로 정해주는 것은 <code>box-sizing</code> 속성이 기본 값인 <code>content-box</code>으로 되어 있을 때만 가능하다. <code>box-sizing</code>이 기본 값으로 설정되어 있으면, <code>width</code>, <code>height</code>, <code>min-width</code>, <code>min-height</code>, <code>max-width</code>, <code>max-height</code>과 같은 크기를 지정하는 CSS 속성들은 컨텐츠 영역의 크기만 변경하게 된다.</p><p>그런데 <code>width</code>, <code>height</code>과 같은 속성들은 주로 컨텐츠 영역의 크기를 변경하려고 하는 것이 아니라 엘리먼트(박스)의 크기를 지정하려고 사용하는 경우가 대부분일 것이다.</p><p>예를 들어서, <code>padding</code>, <code>border</code> 속성이 부여된 엘리먼트의 크기를 너비 200px, 높이 200px으로 하고 싶다면 다음처럼 소스를 작성하려고 할 수도 있다.</p><iframe scrolling="no" width="100%" height="300" src="//jsfiddle.net/dwv5tkmh/25//embedded/html,result/light" frameborder="0" allowfullscreen></iframe><p>이 엘리먼트가 실제 화면에 보여지는 크기를 개발자 도구에서 확인해보면 다음과 같다. </p><img src="/images/css-box-model/calculated-box-size.png" width="300" height="200"><p>엘리먼트의 너비는 바깥에서부터 <code>border</code>, <code>padding</code>, <code>width</code>를 더해서 240px으로 계산되고, 엘리먼트의 높이도 <code>border</code>, <code>padding</code>, <code>height</code>를 더해서 240px으로 계산된다.</p><p>이렇게 계산된 이유는 CSS 코드에서 <code>box-sizing</code> 속성으로 어떤 값도 주어지지 않아서 기본 값인 <code>content-box</code>로 설정됐기 때문이다. <code>box-sizing:content-box</code>로 설정된 엘리먼트는 <code>width</code>, <code>height</code> 속성을 적용해도 <code>padding</code>과 <code>border</code>는 포함하지 않고 <strong>컨텐츠 영역</strong>의 크기만을 지정한다.</p><h2 id="패딩-padding-영역"><a href="#패딩-padding-영역" class="headerlink" title="패딩(padding) 영역"></a>패딩(padding) 영역</h2><p>패딩 영역은 컨텐츠 영역을 감싸면서 엘리먼트의 패딩을 포함하는 투명한 영역이다. 패딩의 두께는 <code>padding-top</code>, <code>padding-right</code>, <code>padding-bottom</code>, <code>padding-left</code> 속성과 네 가지 속성을 축약한 버전인 <code>padding</code>으로 결정된다.</p><h2 id="테두리-border-영역"><a href="#테두리-border-영역" class="headerlink" title="테두리(border) 영역"></a>테두리(border) 영역</h2><p>테두리 영역은 패딩 영역을 감싸면서 엘리먼트의 테두리를 포함하는 영역이며, 테두리의 두께는 <code>border-width</code>, <code>border</code>으로 결정된다. </p><p><code>box-sizing</code> 속성 값 중에는 <code>border-box</code>가 있는데, <code>box-sizing: border-box;</code>를 하게 되면 <code>width</code>, <code>height</code> 같은 엘리먼트(박스)의 크기를 변경하는 CSS 속성들이 <strong>‘border-box’</strong>의 크기를 변경하게 한다. <strong>‘border-box’</strong>는 컨텐츠, 패딩, 테두리 영역를 포함하는 박스를 말한다.</p><p>이제 앞서 살펴본 예제에서 <code>box-sizing: border-box;</code> 코드만을 추가한 버전을 살펴보자.</p><iframe scrolling="no" width="100%" height="300" src="//jsfiddle.net/dwv5tkmh/26//embedded/html,result/light" frameborder="0" allowfullscreen></iframe><p>개발자 도구를 통해서 엘리먼트의 크기를 살펴보면 아래와 같다.</p><img src="/images/css-box-model/calculated-box-size-2.png" width="300" height="200"><p><code>box-sizing</code>이 <code>border-box</code>로 되어 있기 때문에 <code>width</code>, <code>height</code>가 <strong>‘border-box’</strong>의 크기를 변경했다. 그리고 컨텐츠 영역의 크기는 <code>border</code>, <code>padding</code>을 제외한 크기로 계산됐다.</p><h2 id="마진-margin-영역"><a href="#마진-margin-영역" class="headerlink" title="마진(margin) 영역"></a>마진(margin) 영역</h2><p>마진 영역은 테두리 영역을 감싸면서 이웃 엘리먼트로부터 자신을 구분하기 위해 비어있는 공간인 마진을 포함하는 영역이다. 마진의 두께는 <code>margin-left</code>, <code>margin-right</code>, <code>margin-bottom</code>, <code>margin-left</code>와 네 가지를 축약한 버전인 <code>margin</code>으로 결정된다.</p><h2 id="참고-자료"><a href="#참고-자료" class="headerlink" title="참고 자료"></a>참고 자료</h2><ul><li>MDN Box Model : <a href="https://developer.mozilla.org/en-US/docs/Learn/CSS/Introduction_to_CSS/Box_model" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Learn/CSS/Introduction_to_CSS/Box_model</a></li><li>MDN Box Model Introduction : <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Box_Model/Introduction_to_the_CSS_box_model" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Box_Model/Introduction_to_the_CSS_box_model</a></li><li>W3C CSS 2.1 Box Model : <a href="https://www.w3.org/TR/CSS2/box.html" target="_blank" rel="noopener">https://www.w3.org/TR/CSS2/box.html</a></li><li>W3C CSS Box Model Level 3 : <a href="https://www.w3.org/TR/css-box-3/#box-model" target="_blank" rel="noopener">https://www.w3.org/TR/css-box-3/#box-model</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;소개&quot;&gt;&lt;a href=&quot;#소개&quot; class=&quot;headerlink&quot; title=&quot;소개&quot;&gt;&lt;/a&gt;소개&lt;/h2&gt;&lt;p&gt;브라우저는 HTML 문서의 엘리먼트들을 화면에 그리기 위해 각 엘리먼트를 박스(box)로 표현한다. 이 때 모든 HTML 엘리
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Express res.json과 res.send 비교</title>
    <link href="https://haeguri.github.io/2018/12/30/compare-response-json-send-func/"/>
    <id>https://haeguri.github.io/2018/12/30/compare-response-json-send-func/</id>
    <published>2018-12-30T05:15:07.266Z</published>
    <updated>2018-12-30T06:44:01.114Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/haeguri/reviewers" target="_blank" rel="noopener">개인 프로젝트</a>를 개발하면서 서버가 필요하게 되었는데 자바스크립트를 더 공부해보고 싶어서 서버를 Node.js, Express를 사용하여 개발하고 있다.</p><p>지금 작성된 모든 서버 API는 Express를 통해서 JSON 응답을 하도록 구현되어 있다. 그런데 내가 작성한 코드를 살펴보다가 JSON 응답을 보낼 때 Express의 <code>res.json</code> 함수와 <code>res.send</code> 함수를 혼용하고 있었다는 사실을 알았다.  </p><p>클라이언트에서는 API를 호출했을 때 JSON 응답을 받은 것을 확인했으니, 두 개의 함수 모두 JSON 데이터를 보낼 수 있다는 말인데, 이렇게 사용해도 상관없는 것인지 궁금했다. 그래서 <code>res.send</code> 함수와 <code>res.json</code> 함수의 내부 코드를 살펴보기로 했다. </p><h3 id="res-json-source"><a href="#res-json-source" class="headerlink" title="res.json [source]"></a>res.json [<a href="https://github.com/expressjs/express/blob/master/lib/response.js#L239" target="_blank" rel="noopener">source</a>]</h3><p>먼저 <code>res.json</code> 소스코드의 일부는 다음과 같다. </p><pre class=" language-javascript"><code class="language-javascript">res<span class="token punctuation">.</span>json <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">json</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">var</span> val <span class="token operator">=</span> obj<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 생략...</span>  <span class="token keyword">var</span> app <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>app<span class="token punctuation">;</span>  <span class="token keyword">var</span> escape <span class="token operator">=</span> app<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">'json escape'</span><span class="token punctuation">)</span>  <span class="token keyword">var</span> replacer <span class="token operator">=</span> app<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">'json replacer'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">var</span> spaces <span class="token operator">=</span> app<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">'json spaces'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">var</span> body <span class="token operator">=</span> <span class="token function">stringify</span><span class="token punctuation">(</span>val<span class="token punctuation">,</span> replacer<span class="token punctuation">,</span> spaces<span class="token punctuation">,</span> escape<span class="token punctuation">)</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">'Content-Type'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span><span class="token string">'Content-Type'</span><span class="token punctuation">,</span> <span class="token string">'application/json'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>body<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p><code>res.json</code> 함수에 명시된 인자로는 <code>obj</code>가 있다. <code>obj</code>는 JSON 문자열로 변환되서 <code>body</code>라는 변수에 저장된다. 여기서 <strong>Content-Type</strong> 헤더가 세팅되지 않았을 경우 <strong>this</strong>(res 객체)에 <strong>Content-Type</strong> 으로 <strong>application/json</strong>을 세팅한다. 그리고 마지막으로 <code>res.send(body)</code>를 실행하면서 그 결과를 반환한다. 결국은 <code>res.json</code>은 내부적으로 <code>res.send</code>를 호출하고 있었다. </p><h3 id="res-send-source"><a href="#res-send-source" class="headerlink" title="res.send [source]"></a>res.send [<a href="https://github.com/expressjs/express/blob/master/lib/response.js#L107" target="_blank" rel="noopener">source</a>]</h3><p><code>res.send</code>의 소스코드의 일부는 다음과 같으며, <code>chunk</code> 타입에 따른 실행 흐름을 분기하는 코드에 초점을 맞춰서 살펴봤다. </p><pre class=" language-javascript"><code class="language-javascript">res<span class="token punctuation">.</span>send <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">send</span><span class="token punctuation">(</span>body<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> chunk <span class="token operator">=</span> body<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 생략....</span>    <span class="token keyword">switch</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> chunk<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// string defaulting to html</span>        <span class="token keyword">case</span> <span class="token string">'string'</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">'Content-Type'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">type</span><span class="token punctuation">(</span><span class="token string">'html'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token string">'boolean'</span><span class="token punctuation">:</span>        <span class="token keyword">case</span> <span class="token string">'number'</span><span class="token punctuation">:</span>        <span class="token keyword">case</span> <span class="token string">'object'</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>chunk <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                chunk <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>Buffer<span class="token punctuation">.</span><span class="token function">isBuffer</span><span class="token punctuation">(</span>chunk<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">'Content-Type'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">type</span><span class="token punctuation">(</span><span class="token string">'bin'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span>chunk<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 생략..</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><code>res.send</code> 함수의 인자로는 <code>body</code>가 있다. <code>body</code>는 바로 <code>chunk</code>로 할당되고, <code>chunk</code>에 대한 타입 검사가 진행된다. 여기에서 <code>chunk</code>가 <strong>object</strong> 타입이면 <code>res.json</code>을 호출한다. 여기서 의문이 들었는데, 이렇게 되면 두 개의 함수가 서로 호출하기 때문에 함수 호출 스택이 넘쳐버리지 않을까 생각했다. </p><p>그래서 <code>res.send(object)</code>로 코드를 실행했을 때 함수의 실행 순서가 어떻게 되는지 살펴봤다.</p><ol><li><strong>res.send(object)</strong></li><li><strong>res.json(object)</strong></li><li><strong>res.send(string)</strong></li></ol><p><code>res.json</code>에서 <code>res.send</code>를 호출할 때는 <code>body</code>로 문자열을 넘겨주기 때문에, <strong>두 번째 실행</strong>되는 <code>res.send</code>의 <code>chunk</code> 타입은 <strong>string</strong>이다. <code>chunk</code>가 <strong>string</strong>일 경우에는 <strong>object</strong>일 때와 다른 분기를 타게 되서 <code>res.json</code>을 호출하지 않기 때문에, 계속해서 서로를 호출하는 일은 없게 된다.</p><h3 id="실행-흐름을-비교"><a href="#실행-흐름을-비교" class="headerlink" title="실행 흐름을 비교"></a>실행 흐름을 비교</h3><p>그러면 두 개의 함수를 각각 사용했을 때 차이점은 무엇일까 생각해봤다. 그리고 각각을 실행했을 때 실행 흐름이 어떻게 흘러가는지 비교해봤다.</p><p><code>res.send(object)</code>를 실행하면 함수의 호출 순서는 다음과 같다. </p><ol><li><strong>res.send(object)</strong></li><li><strong>res.json(object)</strong></li><li><strong>res.send(string)</strong></li></ol><p>그리고 <code>res.json(object)</code>를 실행했을 때 함수의 호출 순서는 다음과 같다.</p><ol><li><strong>res.json(object)</strong></li><li><strong>res.send(string)</strong></li></ol><p><code>object</code>를 인자로 <code>res.send</code>를 호출하면 <code>res.json</code>을 호출했을 때 보다 <strong>불필요한 호출</strong>이 한 번 더 발생한다.</p><h3 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h3><p>불필요한 함수 호출이 한번 더 발생하는 것은 어쨌든 추가 비용은 발생하는 것이기 때문에, JSON 응답을 한다면 <code>res.send</code>보다 <code>res.json</code>이 적절한 것 같다.</p><p>또한 소스코드를 읽을 때에도 <code>res.json</code>이 JSON 데이터를 보낸다는 의도가 더 명확하게 드러난다. 예를 들어서 <code>res.send({data:1})</code>라면 객체를 즉시 생성해서 전달하기 때문에 JSON을 응답하는 것을 유추할 수 있지만, <code>res.send(data)</code>처럼 객체의 참조값을 변수에 담아서 인자로 넘긴다면 JSON 응답을 하는지 쉽게 구분이 가지 않을 것이다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://github.com/haeguri/reviewers&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;개인 프로젝트&lt;/a&gt;를 개발하면서 서버가 필요하게 되었는데 자바스크립트를 더 공부해보고 싶어서 서버를 No
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>( 번역 ) Refs and the DOM</title>
    <link href="https://haeguri.github.io/2018/12/09/react-refs/"/>
    <id>https://haeguri.github.io/2018/12/09/react-refs/</id>
    <published>2018-12-08T16:10:39.770Z</published>
    <updated>2018-12-09T06:25:18.844Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>리엑트 문서의 “Refs and the DOM”을 번역한 자료<br>원문 : <a href="https://reactjs.org/docs/refs-and-the-dom.html" target="_blank" rel="noopener">https://reactjs.org/docs/refs-and-the-dom.html</a></p></blockquote><p>Ref는 DOM 노드 혹은 <code>render</code> 메서드로 생성된 리엑트 엘리먼트에 접근할 수 있는 방법을 제공한다.</p><p>일반적인 리엑트 데이터 플로우에서는 <a href="https://reactjs.org/docs/components-and-props.html" target="_blank" rel="noopener">props</a>만이 부모 컴포넌트와 자식 컴포넌트와 상호작용할 수 있는 유일한 방법이다. 자식을 수정하기 위해서는 새로운 props을 넘겨줘야 자식이 다시 렌더링된다. 하지만 몇 가지 예외 경우에는 일반적인 데이터 플로에서 벗어나 긴급하게 자식을 수정해야 할 경우가 있다. 여기서 말하는 자식은 리엑트 컴포넌트의 인스턴스이거나 DOM 요소일 수도 있다. 이러한 경우, 리엑트는 비상용 탈출구를 제공한다.</p><h3 id="언제-Ref를-쓰는가"><a href="#언제-Ref를-쓰는가" class="headerlink" title="언제 Ref를 쓰는가?"></a>언제 Ref를 쓰는가?</h3><p>Ref를 사용하면 좋은 몇 가지의 경우가 있다.</p><ul><li>포커스, 텍스트 선택, 미디어 재생을 다룰 때</li><li>애니메이션을 시작할 때</li><li>써드-파티 DOM 라이브러리와 상호작용</li></ul><p>선언적으로 수행할 수 있는 모든 것에 대해서는 Ref를 사용하지 마라.</p><p>예를 들어서, <code>Dialog</code> 컴포넌트의 <code>open()</code>과 <code>close()</code> 메서드를 외부에 노출하는 것 대신에 <code>Dialog</code> 컴포넌트로 <code>isOpen</code> prop을 넘겨줘라.</p><h3 id="Ref를-남용하지-마라"><a href="#Ref를-남용하지-마라" class="headerlink" title="Ref를 남용하지 마라"></a>Ref를 남용하지 마라</h3><p>당신은 처음에 Ref를 당신의 앱에서 “무언가를 일어나도록 하기 위해” 사용할 것이다. 이 경우에는 시간을 갖고 컴포넌트 계층에서 상태를 소유해야 하는 장소에 대해서 비판적으로 생각해봐라. 보통은 상태를 소유하는 적절한 장소가 더 높은 위치에 있는 것을 알게 된다. 이러한 경우에는 <a href="https://reactjs.org/docs/lifting-state-up.html" target="_blank" rel="noopener">Lifting State Up</a> 가이드를 읽어봐라.</p><blockquote><p><strong>주의</strong><br>아래의 예제는 16.3에서 소개된 <code>React.createRef()</code> API를 사용하도록 업데이트됐다. 만약 이전의 React 버전을 사용한다면 <a href="#callback-refs">callback refs</a>를 사용하는 것을 권한다.</p></blockquote><h3 id="Ref-만들기"><a href="#Ref-만들기" class="headerlink" title=" Ref 만들기"></a><a id="creating-refs"></a> Ref 만들기</h3><p>Ref는 <code>React.createRef()</code>로 만들어지며 <code>ref</code> 속성으로 리엑트 엘리먼트와 연결한다. 보통 Ref는 컴포넌트가 생성될 때 인스턴스 프로퍼티로 연결되서 컴포넌트를 통해 참조될 수 있게 된다.</p><pre class=" language-jsx"><code class="language-jsx"><span class="token keyword">class</span> <span class="token class-name">MyComponent</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>    <span class="token function">constructor</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>myRef <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">createRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">ref</span><span class="token script language-javascript"><span class="token punctuation">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>myRef<span class="token punctuation">}</span></span> <span class="token punctuation">/></span></span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="Ref에-접근하기"><a href="#Ref에-접근하기" class="headerlink" title="Ref에 접근하기"></a>Ref에 접근하기</h3><p>Ref가 <code>render</code>에서 엘리먼트로 전달되면, 노드에 대한 참조는 ref의 <code>current</code> 속성에서 접근할 수 있게 된다.</p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> node <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>myRef<span class="token punctuation">.</span>current<span class="token punctuation">;</span></code></pre><p>Ref의 값은 노드의 유형에 따라 달라진다.</p><ul><li><code>ref</code> 속성이 HTML 엘리먼트에서 사용될 때에는 생성자에서 <code>Reac.createRef()</code>로 만들어지는 <code>ref</code>는 <code>current</code> 프로퍼티를 통해 DOM 엘리먼트를 받게 된다.</li><li><code>ref</code> 속성이 커스텀 클래스 컴포넌트에서 사용될 때, <code>ref</code> 객체는 <code>current</code>를 통해 마운트된 컴포넌트의 인스턴스를 받는다.</li><li><strong>함수 컴포넌트는 인스턴스가 없기 때문에 <code>ref</code> 속성은 사용할 수 없다.</strong></li></ul><p>아래의 예제들은 차이점을 보여준다.</p><h4 id="Ref를-DOM-엘리먼트에-추가하기"><a href="#Ref를-DOM-엘리먼트에-추가하기" class="headerlink" title="Ref를 DOM 엘리먼트에 추가하기"></a>Ref를 DOM 엘리먼트에 추가하기</h4><p>이 코드는 <code>ref</code>를 DOM 노드에 대한 참조를 저장하기 위해 사용한다.</p><pre class=" language-jsx"><code class="language-jsx"><span class="token keyword">class</span> <span class="token class-name">CustomTextInput</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>    <span class="token function">constructor</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// textInput DOM 엘리먼트를 저장하기 위한 ref를 만든다.</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>textInput <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">createRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>focusTextInput <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>focusTextInput<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">focusTextInput</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// DOM API를 이용하여 명시적으로 텍스트 입력을 포커스한다.</span>        <span class="token comment" spellcheck="true">// 주의: DOM 노드를 가져오기 위해 `current`에 접근하고 있음.</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>textInput<span class="token punctuation">.</span>current<span class="token punctuation">.</span><span class="token function">focus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// React에게 우리가 생성자에서 만들었던 `textInput` 프로퍼티에 &lt;input> ref를 연결하고 싶다고 말한다.</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span>                    <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span>                    <span class="token attr-name">ref</span><span class="token script language-javascript"><span class="token punctuation">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>textInput<span class="token punctuation">}</span></span> <span class="token punctuation">/></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span>                    <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>button<span class="token punctuation">"</span></span>                    <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Focus</span> <span class="token attr-name">the</span> <span class="token attr-name">text</span> <span class="token attr-name">input"</span>                    <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token punctuation">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>focusTextInput<span class="token punctuation">}</span></span>                <span class="token punctuation">/></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>리엑트는 컴포넌트가 마운트 될 때 DOM 요소를 <code>current</code> 프로퍼티에 할당할 것이며 컴포넌트가 언마운트되면 다시 <code>null</code>을 할당할 것이다. <code>ref</code>는 <code>componentDidMount</code> 혹은 <code>componentDidUpdate</code> 라이프 사이클 훅이 실행되기 전에 갱신된다.</p><h4 id="Ref를-클래스-컴포넌트에-추가하기"><a href="#Ref를-클래스-컴포넌트에-추가하기" class="headerlink" title="Ref를 클래스 컴포넌트에 추가하기"></a><a id="adding-ref-to-class-comp"></a>Ref를 클래스 컴포넌트에 추가하기</h4><p>만약 위의 <code>CustomTextInput</code>을 래핑해서 컴포넌트가 마운트되면 입력이 클릭된 것처럼 하려는 경우, ref를 통해서 커스텀 입력에 접근하고, <code>focusTextInput</code> 메서드를 수동으로 호출할 수 있다.</p><pre class=" language-jsx"><code class="language-jsx"><span class="token keyword">class</span> <span class="token class-name">AutoFocusTextInput</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>    <span class="token function">constructor</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>textInput <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">createRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>textInput<span class="token punctuation">.</span>current<span class="token punctuation">.</span><span class="token function">focusTextInput</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>CustomTextInput</span> <span class="token attr-name">ref</span><span class="token script language-javascript"><span class="token punctuation">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>textInput<span class="token punctuation">}</span></span> <span class="token punctuation">/></span></span>        <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><code>CustomTextInput</code>가 클래스로서 선언되어야만 동작할 수 있음을 유의해라.</p><pre class=" language-jsx"><code class="language-jsx"><span class="token keyword">class</span> <span class="token class-name">CustomTextInput</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// ...</span><span class="token punctuation">}</span></code></pre><h4 id="Ref와-함수형-컴포넌트"><a href="#Ref와-함수형-컴포넌트" class="headerlink" title="Ref와 함수형 컴포넌트"></a>Ref와 함수형 컴포넌트</h4><p>함수형 컴포넌트들은 인스턴스가 없기 때문에 <strong> <code>ref</code> 속성을 가질 수 없을 것이다.</strong></p><pre class=" language-jsx"><code class="language-jsx"><span class="token keyword">function</span> <span class="token function">MyFunctionalComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token punctuation">/></span></span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Parent</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>    <span class="token function">constructor</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>textInput <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">createRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 이것은 동작하지 않을 것이다!</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>MyFunctionalComponent</span> <span class="token attr-name">ref</span><span class="token script language-javascript"><span class="token punctuation">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>textInput<span class="token punctuation">}</span></span> <span class="token punctuation">/></span></span>        <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>만약 컴포넌트에 대한 ref가 필요하다면 라이프 사이클 메서드나 상태가 필요할 경우와 마찬가지로 함수형 컴포넌트들은 클래스로 변환해야 한다.</p><p>그러나 <strong>함수형 컴포넌트 내에서</strong> DOM 엘리먼트 혹은 클래스 컴포넌트를 참조한다면 <strong>ref 속성을 사용할 수 있다</strong>.</p><pre class=" language-jsx"><code class="language-jsx"><span class="token keyword">function</span> <span class="token function">CustomTextInput</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// textInput은 여기서 선언되어야 ref가 DOM 엘리먼트를 참조할 수 있다.</span>    <span class="token keyword">let</span> textInput <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">createRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">function</span> <span class="token function">handleClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        textInput<span class="token punctuation">.</span>current<span class="token punctuation">.</span><span class="token function">focus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span>                <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span>                <span class="token attr-name">ref</span><span class="token script language-javascript"><span class="token punctuation">=</span><span class="token punctuation">{</span>textInput<span class="token punctuation">}</span></span> <span class="token punctuation">/></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span>                <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>button<span class="token punctuation">"</span></span>                <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Focus</span> <span class="token attr-name">the</span> <span class="token attr-name">text</span> <span class="token attr-name">input"</span>                <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token punctuation">=</span><span class="token punctuation">{</span>handleClick<span class="token punctuation">}</span></span>            <span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="부모-컴포넌트에-DOM-Ref를-노출하기"><a href="#부모-컴포넌트에-DOM-Ref를-노출하기" class="headerlink" title="부모 컴포넌트에 DOM Ref를 노출하기"></a>부모 컴포넌트에 DOM Ref를 노출하기</h3><p>드문 경우에 부모 컴포넌트에서 자식의 DOM 노드에 접근하기를 원할 수 있다. 이것은 컴포넌트 캡슐화를 망가뜨리기 때문에 일반적으로 추천되지 않지만, 포커스를 주거나 자식 DOM 노드의 크기나 포지션을 측정할 때 유용할 수 있다.</p><p>위에서 <a href="#adding-ref-to-class-comp">자식 컴포넌트에 ref를 추가할 수 있었지만</a>, DOM 노드보다는 컴포넌트 인스턴스만을 가져오기 때문에 이것은 이상적인 해결책이 아니다. 덧붙이면 이것은 함수형 컴포넌트로도 할 수 없다.</p><p>이러한 경우에서 리엑트 16.3 이상을 사용한다면 <a href="https://reactjs.org/docs/forwarding-refs.html" target="_blank" rel="noopener">ref forwarding</a>을 추천한다. Ref Forwarding은 컴포넌트가 자식 컴포넌트의 ref를 노출하는 것을 선택할 수 있게 한다. 자식의 DOM 노드를 부모 컴포넌트에 노출하는 방법에 대한 자세한 예제는 <a href="https://reactjs.org/docs/forwarding-refs.html#forwarding-refs-to-dom-componentsV" target="_blank" rel="noopener">ref forwarding 문서</a>에서 찾을 수 있다.</p><p>만약 리엑트 16.2 이하을 사용하거나 ref forwarding에 의해 제공되는 기능보다 유연해야 한다면, <a href="https://gist.github.com/gaearon/1a018a023347fe1c2476073330cc5509" target="_blank" rel="noopener">이 대안</a>을 사용하거나 다르게 명명된 prop으로 ref를 명시적으로 넘겨줄 수 있다.</p><p>가능하다면, DOM 노드를 노출하지 않을 것을 권장하지만, 때때로 유용할 수 있다. 이 접근 법은 자식 컴포넌트에 어떤 코드를 추가해야 할 경우의 접근 법이다. 만약 자식 컴포넌트 구현체를 변경할 수 없다면 마지막 선택지는 <a href="https://reactjs.org/docs/react-dom.html#finddomnode" target="_blank" rel="noopener">findDOMNode</a>를 사용하는 것이지만, 실망스러울 것이다.</p><h3 id="Callback-Refs"><a href="#Callback-Refs" class="headerlink" title=" Callback Refs"></a><a id="callback-refs"></a> Callback Refs</h3><p>리엑트는 Ref를 설정하기 위한 또 다른 방법인 ‘callback refs’를 제공한다. ‘callback refs’는 Ref가 설정되고 해제될 때 더욱 세세한 제어를 하게 한다.</p><p><code>createRef( )</code>로 만든 <code>ref</code>속성을 넘겨주는 대신에, 함수를 넘겨줄 수 있다. 함수는 리엑트 컴포넌트 인스턴스 혹은 HTML DOM 엘리먼트를 인자로 받는다. 그리고 인자는 다른 곳에 저장하고, 접근할 수 있다.</p><p>아래의 예제는 인스턴스 프로퍼티에서 DOM 노드에 접근할 참조를 저장하기 위한 <code>ref</code> 콜백을 사용하는 일반적인 패턴을 구현한다. </p><pre class=" language-jsx"><code class="language-jsx"><span class="token keyword">class</span> <span class="token class-name">CustomTextInput</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>    <span class="token function">constructor</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>textInput <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>setTextInputRef <span class="token operator">=</span> element <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>textInput <span class="token operator">=</span> element<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>focusTextInput <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 원래의 DOM API를 이용하여 텍스트 입력을 포커싱한다</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>textInput<span class="token punctuation">)</span> <span class="token keyword">this</span><span class="token punctuation">.</span>textInput<span class="token punctuation">.</span><span class="token function">focus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 마운트됐을 때 입력을 포커싱을 한다.</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">focusTextInput</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 인스턴스 필드(`this.textInput`)에 텍스트 입력 DOM 엘리먼트에 대한</span>        <span class="token comment" spellcheck="true">// 참조를 저장하기 위해 `ref` 콜백을 사용한다</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span>                    <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span>                    <span class="token attr-name">ref</span><span class="token script language-javascript"><span class="token punctuation">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>setTextInputRef<span class="token punctuation">}</span></span>                <span class="token punctuation">/></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span>                    <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>button<span class="token punctuation">"</span></span>                    <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Focus</span> <span class="token attr-name">the</span> <span class="token attr-name">text</span> <span class="token attr-name">input"</span>                    <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token punctuation">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>focusTextInput<span class="token punctuation">}</span></span>                <span class="token punctuation">/></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>리엑트는 컴포넌트가 마운트되면 DOM 엘리먼트를 파라메터로 <code>ref</code> 콜백을 실행할 것이다. 그리고 언마운트되면 <code>null</code>을 파라메터로 호출할 것이다. Ref는 <code>componentDidMount</code> 혹은 <code>componentDidUpdate</code>가 호출되기 전에 최신 상태로 보장된다.</p><p><code>React.createRef()</code>로 만든 객체 Ref와 같이 컴포넌트 사이에서 Ref 콜백을 넘겨줄 수 있다. 컴포넌트 사이에서 콜백을 호출할 수 있다</p><pre class=" language-jsx"><code class="language-jsx"><span class="token keyword">function</span> <span class="token function">CustomTextInput</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">ref</span><span class="token script language-javascript"><span class="token punctuation">=</span><span class="token punctuation">{</span>props<span class="token punctuation">.</span>inputRef<span class="token punctuation">}</span></span> <span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Parent</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>CustomTextInput</span>                <span class="token attr-name">inputRef</span><span class="token script language-javascript"><span class="token punctuation">=</span><span class="token punctuation">{</span>el <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">this</span><span class="token punctuation">.</span>inputElement <span class="token operator">=</span> el<span class="token punctuation">}</span></span>            <span class="token punctuation">/></span></span>        <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>위의 예제에서, <code>Parent</code>는 ref 콜백을 <code>inputRef</code> prop으로 <code>CustomTextInput</code>에 넘겨준다. <code>CustomTextInput</code>은 넘겨받은 함수를 특별한 <code>ref</code> 속성으로써  <code>&lt;input&gt;</code>로 넘긴다.</p><h3 id="레거시-API-문자열-Ref"><a href="#레거시-API-문자열-Ref" class="headerlink" title="레거시 API: 문자열 Ref"></a>레거시 API: 문자열 Ref</h3><p>예전에 리엑트를 사용했다면 <code>ref</code> 속성이 <code>”textInput&quot;</code>과 같이 문자열이고, DOM 노드를 <code>this.refs.textInput</code>으로 접근하는 오래된 API에 더 친숙할 것이다. 문자열 Ref는 <a href="https://github.com/facebook/react/pull/8333#issuecomment-271648615" target="_blank" rel="noopener">어떤 이슈</a>들을 가져서 레거시로 간주됐고, 앞으로의 릴리즈에서 제거될 것이기 때문에 문자열 Ref를 사용하는 일은 피해라</p><blockquote><p><strong>주의</strong><br>Ref에 접근하기 위해 <code>this.refs.textInput</code>를 사용하고 있다면, <a href="#callback-refs">콜백 패턴</a>이나 <a href="#creating-refs">createRef API</a>를 대신에 사용할 것을 권장한다.</p></blockquote><h3 id="Callback-Refs를-사용할-때-주의사항"><a href="#Callback-Refs를-사용할-때-주의사항" class="headerlink" title="Callback Refs를 사용할 때 주의사항"></a>Callback Refs를 사용할 때 주의사항</h3><p><code>ref</code> 콜백이 인라인 함수로 정의된다면 컴포넌트가 업데이트되는 동안 두 번 호출될 것이다. 첫 번째는 <code>null</code>, 그 다음에는 DOM 엘리먼트가 파라메터로 넘어간다. 이것은 각각의 <code>render</code> 메서드로 함수의 새 인스턴스가 만들어지기 때문인데, 그래서 리엑트는 예전의 ref를 비워우고 새로운 것으로 설정해줄 필요가 있다. <code>ref</code> 콜백을 클래스에 바운드된 메서드로 정의하면 이것을 피할 수 있지만, 대부분의 경우에서는 문제가 되지 않음을 기억해라.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;리엑트 문서의 “Refs and the DOM”을 번역한 자료&lt;br&gt;원문 : &lt;a href=&quot;https://reactjs.org/docs/refs-and-the-dom.html&quot; target=&quot;_blank&quot; rel=&quot;noo
      
    
    </summary>
    
    
  </entry>
  
</feed>
